<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>17 | 跳表：为什么Redis一定要用跳表来实现有序集合？</title>
</head>

<body>
    <script>
        // 常量
        const hashNum = Math.pow(2, 32); // hash 取模
        const __empty = {}; // 查询当前层数小于当比对值为空时返回
        const __last = {};  // 查询当前层数大于等于当比对值为空时返回

        // 双向链表
        class DoubleNode {
            constructor(value) {
                if (value instanceof DoubleNode) return value;
                this.value = value;
                this.pre = null;
                this.next = null;
            }
            setNext(next) {
                this.next = next;
            }
            setPre(pre) {
                this.pre = pre;
            }
            clear() {
                this.value = null;
                this.pre = null;
                this.next = null;
            }
        }
        class DoublyLinkedList {
            constructor() {
                this.firstNode = null;
                this.endtNode = null;
                this.length = 0;
            }
            // 任意位置插入
            insert(value, position) {
                if (position !== undefined && (typeof position !== "number" || position < 0 || (this.length && position > this.length - 1))) return false;
                const node = new DoubleNode(value);
                let f = this.firstNode;
                let e = this.endtNode;
                if (!f || !e) {
                    this.firstNode = node
                    this.endtNode = node
                } else if (position === undefined) {
                    e.setNext(node)
                    node.setPre(e)
                    this.endtNode = node
                } else if (position === 0) {
                    f.setPre(node)
                    node.setNext(f)
                    this.firstNode = node
                } else {
                    let current = this.findByIndex(position);
                    current.pre.setNext(node)
                    node.setPre(current.pre)
                    node.setNext(current)
                    current.setPre(node)
                }
                this.length++;
                return true;
            }
            // 依据索引删除
            removeByIndex(index) {
                if (typeof index !== "number" || index < 0 || index > this.length - 1) return false;
                let f = this.firstNode;
                let e = this.endtNode;
                if (!this.getSize()) {
                    return false
                } else if (index === this.length - 1) {
                    this.endtNode = this.endtNode.pre;
                    this.endtNode.setNext(null);
                    e.clear()
                } else if (index === 0) {
                    this.firstNode = this.firstNode.next;
                    this.firstNode.setPre(null);
                    f.clear()
                } else {
                    let current = this.findByIndex(index);
                    let p = current.pre;
                    let n = current.next;
                    p.setNext(n);
                    n.setPre(p);
                    current.clear()
                }
                this.length--;
                return true;
            }
            // 依据 节点 删除自身
            removeByNode(node) {
                let f = this.firstNode;
                let e = this.endtNode;
                if (node === f) {
                    this.firstNode = node.next;
                    this.firstNode.setPre(null);
                } else if (node === e) {
                    this.endtNode = node.pre;
                    this.firstNode.setNext(null);
                    node.clear()
                } else {
                    let p = node.pre;
                    let n = node.next;
                    p.setNext(n);
                    n.setPre(p);
                }
                node.clear();
                this.length--;
            }
            // 依据索引查询元素
            findByIndex(index) {
                if (typeof index !== "number" || index < 0 || index >= this.length) return -1;
                let node = this.firstNode;
                let len = 1;
                while (len <= index) {
                    len++;
                    node = node.next
                }
                return node
            }
            // 依据 值 查询元素
            findByValue(value) {
                let node = this.firstNode;
                while (node) {
                    if (node.value === value) {
                        return node;
                    } else {
                        node = node.next;
                    }
                }
                return -1
            }
            // 依据 node 查询后续是否存在该元素
            findByValue(value) {
                let node = this.firstNode;
                while (node) {
                    if (node.value === value) {
                        return node;
                    } else {
                        node = node.next;
                    }
                }
                return -1
            }
            // 插入某个节点之前
            insertBeforeNode(before, value) {
                if (!value ||
                    !before ||
                    !(before instanceof DoubleNode)
                ) return false
                const node = new DoubleNode(value);
                let f = this.firstNode;
                if (!before.pre) {
                    f.setPre(node)
                    node.setNext(f)
                    this.firstNode = node
                } else {
                    before.pre.setNext(node)
                    node.setPre(before.pre)
                    node.setNext(before)
                    before.setPre(node)
                }
                this.length++;
                return true;
            }
            // 插入某个节点之后
            insertAfterNode(after, value) {
                if (!value ||
                    !after ||
                    !(after instanceof DoubleNode)
                ) return false;
                const node = new DoubleNode(value);
                let e = this.endtNode;
                if (!after.next) {
                    e.setNext(node)
                    node.setPre(e)
                    this.endtNode = node
                } else {
                    after.next.setPre(node)
                    node.setNext(after.next)
                    after.setNext(node)
                    node.setPre(after)
                }
                this.length++;
                return true;
            }

            // // 查询第一个大于给定值的元素
            // findFirstGtNode(value, compare, startNode) {
            //     if (!this.getSize()) return __empty
            //     compare = compare || DoublyLinkedList.compare;
            //     let first = startNode || this.firstNode;
            //     while (first) {
            //         let num = compare(value, first.value && first.value._value && first.value._value.key);
            //         if (num < 0) return first;
            //         first = first.next
            //     }
            //     return __last
            // }

            // 查询最后一个小于等于给定值的元素
            findLastEqNode(key, startNode) {
                if (!this.getSize()) return __empty;
                let first = startNode || this.firstNode;
                const compare = DoublyLinkedList.compare;
                let num = compare(key, first.value && first.value._hashKey);
                if (num < 0) {
                    if (first === this.firstNode) return __empty
                    return first
                }
                while (first.next) {
                    let next = first.next;
                    if (num >= 0 && (num = compare(key, next.value && next.value._hashKey)) < 0) return first;
                    first = first.next
                }
                return __last
            }
            // 获取链表头
            getFirstNode() {
                return this.firstNode;
            }
            // 获取链表尾
            getEndtNode() {
                return this.endtNode;
            }
            // 获取链表长度
            getSize() {
                return this.length;
            }
            // 默认比对的方法
            static compare(a, b) {
                return a - b
            }
        }
        // 跳表节点
        class SkipListNode {
            constructor(hashKey, key, value, level = 0) {
                this._value = { key, value };
                this._level = level;
                this._hashKey = hashKey;
                for (let i = 0; i <= level; i++) {
                    this[i] = new DoubleNode(this)
                }
            }
            clear() {
                for (let i = 0; i <= this._level; i++) {
                    this[i] && this[i].clear()
                }
                this._value = null;
                this._level = null;
            }
        }

        /**
        * 跳表的实现
        * @params level      number   层级
        * @params compare   function 值之间比对的方法
        */

        class SkipList {
            constructor({
                level = 5,
                compare,
                hashNum,
            }) {
                // 用于设置当前跳表层级
                this.level = level;
                /**
                * 用于设置当前跳表层级双向链表引用
                * 格式 ： {
                *       0 ：new DoubleNode()
                *       1 ：new DoubleNode()
                *       2 ：new DoubleNode()
                *       3 ：new DoubleNode()
                *    }
                */
                this.linkedListMap = {};
                this.init();
            }
            // 初始化 用于设置 表头 表尾
            init() {
                let map = this.linkedListMap;
                for (let i = 0; i <= this.level; i++) {
                    map[i] = new DoublyLinkedList();
                }
            }
            //  添加
            add(key, value) {
                if (key === undefined) return;
                let linkedListMap = this.linkedListMap;
                let level = SkipList.randomlevel(this.level);
                const hashKey = SkipList.getHash(key);
                let node = new SkipListNode(hashKey, key, value, level);
                this.insert(node)
            }
            // 插入
            insert(node) {
                const key = node._hashKey;
                const linkedListMap = this.linkedListMap;
                let current = null;
                for (let i = this.level; i >= 0; i--) {
                    let linkedList = linkedListMap[i];
                    let value = linkedList.findLastEqNode(key, current);
                    console.log('value', value)
                    if (value === __empty) {
                        node[i] && linkedList.insert(node[i], 0)
                        current = null;
                    } else if (value === __last) {
                        current = linkedList.getEndtNode()
                        node[i] && linkedList.insert(node[i])
                    } else {
                        linkedList.insertAfterNode(value, node[i])
                        current = value
                    }
                }
            }
            // 获取随机层数
            static randomlevel(level) {
                let current = 0;
                while (current < level) {
                    if (Math.random() > 0.5) {
                        ++current;
                    } else {
                        return current
                    }
                }
                return current
            }
            // 默认比对的方法
            static compare(a, b) {
                return a - b
            }

            // 默认转hash值的方法
            static getHash(key) {
                key += '';
                const len = key.length;
                let num = 0;
                for (let i = 0; i < len; i++) {
                    num += key.charCodeAt(i)
                }
                return num % hashNum;
            }
        }

        let a = new SkipList({
            level: 3,
            compare: function (a, b) {
                return a - b
            }
        })
        a.add(1, 1)
        a.add(4, 4)
        a.add(6, 6)
        a.add(2, 2)
        a.add(5, 5)
        console.log(a)
    </script>
</body>

</html>