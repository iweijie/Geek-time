<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？</title>
</head>

<body>
    <script>
        // 完全二叉树  数组实现方式
        class CompleteBinaryTree {
            constructor() {
                this.store = [undefined, "A","B","C","D","E","F","G"];
            }
            add(value) {
                this.store.push(value)
            }
            // 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
            preorder() {
                const arr = [];
                const { store } = this;
                const len = store.length;
                function order(index, tree, len) {
                    const l = index * 2;
                    const r = index * 2 + 1;
                    arr.push(tree[index]);
                    if (l < len) {
                        order(l, tree, len)
                    }
                    if (r < len) {
                        order(r, tree, len)
                    }
                }
                order(1, store, len);
                return arr

            }
            // 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
            inorder() {
                const arr = [];
                const { store } = this;
                const len = store.length;
                function order(index, tree, len) {
                    const l = index * 2;
                    const r = index * 2 + 1;
                    if (l < len) {
                        order(l, tree, len)
                    }
                    arr.push(tree[index]);
                    if (r < len) {
                        order(r, tree, len)
                    }
                }
                order(1, store, len);
                return arr

            }
            // 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
            postorder() {
                const arr = [];
                const { store } = this;
                const len = store.length;
                function order(index, tree, len) {
                    const l = index * 2;
                    const r = index * 2 + 1;
                    if (l < len) {
                        order(l, tree, len)
                    }
                    if (r < len) {
                        order(r, tree, len)
                    }
                    arr.push(tree[index]);
                }
                order(1, store, len);
                return arr

            }
        }

        const a = new CompleteBinaryTree();
        console.log(a.preorder())
        console.log(a.inorder())
        console.log(a.postorder())

    </script>
</body>

</html>