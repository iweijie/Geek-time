<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</title>
</head>

<body>
    <script>
        // 大顶堆:节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”
        // 当前 Heap 依据 compare 建立大顶堆还是小顶堆
        class Heap {
            constructor({
                list = [],
                compare
            }) {
                this.store = [undefined]
                this.compare = compare || Heap.dufaultCompare
                this.buildHeap(list, list.length)
            }
            buildHeap(list = []) {
                const {
                    store
                } = this;
                store.push(...list)
                // 1 至 Math.floor(store.length / 2) -- 为有子节点的节点  
                for (let i = Math.floor(store.length / 2); i > 0; i--) {
                    this.sink(i)
                }
                // for (let i = tier - 1; i > 0; i--) {
                //     const start = Math.pow(2, i - 1)
                //     const end = Math.pow(2, i)
                //     for (let j = start; j < end; j++) {
                //         debugger
                //         this.sink(j)
                //         // this.heapify(store, 15, j);
                //     }
                // }
            }
            // 插入节点 
            insert(node) {
                const {
                    store,
                    compare
                } = this
                store.push(node)
                this.rise(store.length - 1)
            }
            // 上浮
            rise(index) {
                const {
                    store,
                    compare
                } = this
                let node = store[index]
                while (true) {
                    // 父节点索引
                    const i = Math.floor(index / 2)
                    if (compare(store[i], node) <= 0) {
                        break
                    } else {
                        Heap.swap(store, index, i)
                        index = i
                    }
                }
            }
            // 下沉
            sink(index) {
                const {
                    store,
                    compare
                } = this;
                const len = store.length
                while (true) {
                    let c = index
                    if (index * 2 <= len && compare(store[index], store[index * 2]) > 0) {
                        c = index * 2
                    }

                    if (index * 2 + 1 <= len && compare(store[c], store[index * 2 + 1]) > 0) {
                        c = index * 2 + 1
                    }
                    // 如果 c === index 即表示 左右节点均不需要修改 直接返回就好
                    if (c === index) break
                    Heap.swap(store, c, index)
                    index = c
                }
            }

            // 删除节点 by 索引 
            delByIndex(index) {
                const {
                    store
                } = this;
                let r = store[index]
                if (r === undefined) return r
                store[index] = store[store.length - 1]
                store.pop()
                this.sink(index)
                return r
            }
            getSerialization() {
                const {
                    store
                } = this;
                const list = this.store = store.slice(0)
                const arr = []
                while (list.length > 1) {
                    arr.push(this.delByIndex(1))
                }
                this.store = store
                return arr
            }
            getTier() {
                return this.getHeight() + 1
            }
            getHeight() {
                return Math.floor(Math.log2(this.store.length - 1))
            }
            getLength() {
                return this.store.length
            }
            isEmpty() {
                return this.store.length <= 1
            }
            static dufaultCompare(a, b) {
                return b - a
            }
            static swap(arr, i, j) {
                if (arr[i] === arr[j]) return;
                [arr[i], arr[j]] = [arr[j], arr[i]]
            }
        }


// 堆排序
const quicksortByHeap = (function () {
    // 建堆
    const buildHeap = (store = [], compare) => {
        // 1 至 Math.floor(store.length / 2) -- 为有子节点的节点  
        for (let i = Math.floor(store.length / 2); i > 0; i--) {
            sink(store, i, compare)
        }
    }
    // 下沉
    const sink = (store = [], index = 0, compare) => {
        const len = store.length
        while (true) {
            let c = index
            if (index * 2 <= len && compare(store[index], store[index * 2]) > 0) {
                c = index * 2
            }

            if (index * 2 + 1 <= len && compare(store[c], store[index * 2 + 1]) > 0) {
                c = index * 2 + 1
            }
            // 如果 c === index 即表示 左右节点均不需要修改 直接返回就好
            if (c === index) break
            swap(store, c, index)
            index = c
        }
    }
    // 删除
    const del = (store = [], index, compare) => {
        let r = store[index]
        if (r === undefined) return r
        store[index] = store[store.length - 1]
        store.pop()
        sink(store, index, compare)
        return r
    }
    const getSerialization = (store = [], compare) => {
        const arr = []
        while (store.length > 1) {
            arr.push(del(store, 1, compare))
        }
        return arr
    }

    const swap = (arr, i, j) => {
        if (arr[i] === arr[j]) return;
        [arr[i], arr[j]] = [arr[j], arr[i]]
    }
    const dufaultCompare = (a, b) => {
        return b - a
    }
    return function (arr, compare) {
        compare = compare || dufaultCompare
        arr = [undefined, ...arr]
        buildHeap(arr, compare)
        return getSerialization(arr, compare)
    }
})()

var arr = ((num = 8888) => {
    var arr = [];
    for (var i = 0; i < num; i++) {
        arr.push(Math.floor(Math.random() * num))
    }
    return arr
})(100)
console.time("Heap")
console.log(quicksortByHeap(arr))
console.timeEnd("Heap")
    </script>
</body>

</html>